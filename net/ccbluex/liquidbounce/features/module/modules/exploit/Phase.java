package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.api.minecraft.client.block.IBlock;
import net.ccbluex.liquidbounce.api.minecraft.client.network.IINetHandlerPlayClient;
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket;
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketPlayer;
import net.ccbluex.liquidbounce.api.minecraft.util.IAxisAlignedBB;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.BlockBBEvent;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.MoveEvent;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.PushOutEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.timer.TickTimer;
import net.ccbluex.liquidbounce.value.ListValue;

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
/* loaded from: L-out.jar:net/ccbluex/liquidbounce/features/module/modules/exploit/Phase.class */
public class Phase extends Module {
    private boolean mineplexClip;
    private final ListValue modeValue = new ListValue("Mode", new String[]{"Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"}, "Vanilla");
    private final TickTimer tickTimer = new TickTimer();
    private final TickTimer mineplexTickTimer = new TickTimer();

    @EventTarget
    public void onUpdate(UpdateEvent updateEvent) {
        boolean zCollideBlockIntersects;
        IINetHandlerPlayClient netHandler;
        zCollideBlockIntersects = BlockUtils.collideBlockIntersects(f157mc.getThePlayer().getEntityBoundingBox(), Phase::lambda$onUpdate$0);
        if (zCollideBlockIntersects && !((String) this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            f157mc.getThePlayer().setNoClip(true);
            f157mc.getThePlayer().setMotionY(0.0d);
            f157mc.getThePlayer().setOnGround(false);
        }
        netHandler = f157mc.getNetHandler();
        switch (((String) this.modeValue.get()).toLowerCase()) {
            case "vanilla":
                if (f157mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && f157mc.getThePlayer().isCollidedVertically() && (!zCollideBlockIntersects || f157mc.getThePlayer().isSneaking())) {
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5d, 0.0d, 0.5d, true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY() + 0.2d, f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5d, 0.0d, 0.5d, true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX() + 0.5d, f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + 0.5d, true));
                    double radians = Math.toRadians(f157mc.getThePlayer().getRotationYaw());
                    f157mc.getThePlayer().setPosition(f157mc.getThePlayer().getPosX() + ((-Math.sin(radians)) * 0.04d), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + (Math.cos(radians) * 0.04d));
                    this.tickTimer.reset();
                    break;
                }
                break;
            case "skip":
                if (f157mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && f157mc.getThePlayer().isCollidedVertically() && (!zCollideBlockIntersects || f157mc.getThePlayer().isSneaking())) {
                    double direction = MovementUtils.getDirection();
                    double d = (-Math.sin(direction)) * 0.3d;
                    double dCos = Math.cos(direction) * 0.3d;
                    for (int i = 0; i < 3; i++) {
                        f157mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY() + 0.06d, f157mc.getThePlayer().getPosZ(), true));
                        f157mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX() + (d * i), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + (dCos * i), true));
                    }
                    f157mc.getThePlayer().setEntityBoundingBox(f157mc.getThePlayer().getEntityBoundingBox().offset(d, 0.0d, dCos));
                    f157mc.getThePlayer().setPositionAndUpdate(f157mc.getThePlayer().getPosX() + d, f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + dCos);
                    this.tickTimer.reset();
                    break;
                }
                break;
            case "spartan":
                if (f157mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && f157mc.getThePlayer().isCollidedVertically() && (!zCollideBlockIntersects || f157mc.getThePlayer().isSneaking())) {
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5d, 0.0d, 0.5d, true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX(), f157mc.getThePlayer().getPosY() - 0.2d, f157mc.getThePlayer().getPosZ(), true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5d, 0.0d, 0.5d, true));
                    netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(f157mc.getThePlayer().getPosX() + 0.5d, f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + 0.5d, true));
                    double radians2 = Math.toRadians(f157mc.getThePlayer().getRotationYaw());
                    f157mc.getThePlayer().setPosition(f157mc.getThePlayer().getPosX() + ((-Math.sin(radians2)) * 0.04d), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + (Math.cos(radians2) * 0.04d));
                    this.tickTimer.reset();
                    break;
                }
                break;
            case "clip":
                if (this.tickTimer.hasTimePassed(2) && f157mc.getThePlayer().isCollidedVertically() && (!zCollideBlockIntersects || f157mc.getThePlayer().isSneaking())) {
                    double radians3 = Math.toRadians(f157mc.getThePlayer().getRotationYaw());
                    double posX = f157mc.getThePlayer().getPosX();
                    double posZ = f157mc.getThePlayer().getPosZ();
                    int i2 = 1;
                    while (true) {
                        if (i2 <= 10) {
                            double d2 = (-Math.sin(radians3)) * i2;
                            double dCos2 = Math.cos(radians3) * i2;
                            if (!classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(posX + d2, f157mc.getThePlayer().getPosY(), posZ + dCos2))) || !classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(posX + d2, f157mc.getThePlayer().getPosY() + 1.0d, posZ + dCos2)))) {
                                i2++;
                            } else {
                                f157mc.getThePlayer().setPosition(posX + d2, f157mc.getThePlayer().getPosY(), posZ + dCos2);
                            }
                        }
                    }
                    this.tickTimer.reset();
                    break;
                }
                break;
            case "aac3.5.0":
                if (this.tickTimer.hasTimePassed(2) && f157mc.getThePlayer().isCollidedVertically() && (!zCollideBlockIntersects || f157mc.getThePlayer().isSneaking())) {
                    double radians4 = Math.toRadians(f157mc.getThePlayer().getRotationYaw());
                    f157mc.getThePlayer().setPosition(f157mc.getThePlayer().getPosX() + (-Math.sin(radians4)), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + Math.cos(radians4));
                    this.tickTimer.reset();
                    break;
                }
                break;
        }
        this.tickTimer.update();
    }

    private static Boolean lambda$onUpdate$0(IBlock iBlock) {
        return Boolean.valueOf(!classProvider.isBlockAir(iBlock));
    }

    @EventTarget
    public void onBlockBB(BlockBBEvent blockBBEvent) {
        if (f157mc.getThePlayer() != null && BlockUtils.collideBlockIntersects(f157mc.getThePlayer().getEntityBoundingBox(), Phase::lambda$onBlockBB$1) && blockBBEvent.getBoundingBox() != null && blockBBEvent.getBoundingBox().getMaxY() > f157mc.getThePlayer().getEntityBoundingBox().getMinY() && !((String) this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            IAxisAlignedBB boundingBox = blockBBEvent.getBoundingBox();
            blockBBEvent.setBoundingBox(classProvider.createAxisAlignedBB(boundingBox.getMaxX(), f157mc.getThePlayer().getEntityBoundingBox().getMinY(), boundingBox.getMaxZ(), boundingBox.getMinX(), boundingBox.getMinY(), boundingBox.getMinZ()));
        }
    }

    private static Boolean lambda$onBlockBB$1(IBlock iBlock) {
        return Boolean.valueOf(!classProvider.isBlockAir(iBlock));
    }

    @EventTarget
    public void onPacket(PacketEvent packetEvent) {
        IPacket packet = packetEvent.getPacket();
        if (classProvider.isCPacketPlayer(packet)) {
            ICPacketPlayer iCPacketPlayerAsCPacketPlayer = packet.asCPacketPlayer();
            if (((String) this.modeValue.get()).equalsIgnoreCase("AAC3.5.0")) {
                float direction = (float) MovementUtils.getDirection();
                iCPacketPlayerAsCPacketPlayer.setX(iCPacketPlayerAsCPacketPlayer.getX() - (Math.sin(direction) * 1.0E-8d));
                iCPacketPlayerAsCPacketPlayer.setZ(iCPacketPlayerAsCPacketPlayer.getZ() + (Math.cos(direction) * 1.0E-8d));
            }
        }
    }

    @EventTarget
    private void onMove(MoveEvent moveEvent) {
        if (((String) this.modeValue.get()).equalsIgnoreCase("mineplex")) {
            if (f157mc.getThePlayer().isCollidedVertically()) {
                this.mineplexClip = true;
            }
            if (!this.mineplexClip) {
                return;
            }
            this.mineplexTickTimer.update();
            moveEvent.setX(0.0d);
            moveEvent.setZ(0.0d);
            if (this.mineplexTickTimer.hasTimePassed(3)) {
                this.mineplexTickTimer.reset();
                this.mineplexClip = false;
            } else if (this.mineplexTickTimer.hasTimePassed(1)) {
                double d = this.mineplexTickTimer.hasTimePassed(2) ? 1.6d : 0.06d;
                double direction = MovementUtils.getDirection();
                f157mc.getThePlayer().setPosition(f157mc.getThePlayer().getPosX() + ((-Math.sin(direction)) * d), f157mc.getThePlayer().getPosY(), f157mc.getThePlayer().getPosZ() + (Math.cos(direction) * d));
            }
        }
    }

    @EventTarget
    public void onPushOut(PushOutEvent pushOutEvent) {
        pushOutEvent.cancelEvent();
    }

    public String getTag() {
        return (String) this.modeValue.get();
    }
}
